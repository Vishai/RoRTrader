import { MockDataGenerator } from './mockDataGenerator';
import { WebhookSimulator } from './webhookSimulator';
import { PerformanceSimulator } from './performanceSimulator';

export interface DemoConfig {
  enabled: boolean;
  autoGenerateData: boolean;
  simulateWebhooks: boolean;
  webhookInterval: number; // milliseconds
  showDemoWatermark: boolean;
}

export class DemoService {
  private mockDataGenerator: MockDataGenerator;
  private webhookSimulator: WebhookSimulator;
  private performanceSimulator: PerformanceSimulator;
  private demoConfig: DemoConfig;
  private webhookTimers: Map<string, NodeJS.Timer> = new Map();

  constructor() {
    this.mockDataGenerator = new MockDataGenerator();
    this.webhookSimulator = new WebhookSimulator();
    this.performanceSimulator = new PerformanceSimulator();
    
    // Default demo configuration
    this.demoConfig = {
      enabled: process.env.DEMO_MODE === 'true',
      autoGenerateData: true,
      simulateWebhooks: true,
      webhookInterval: 30000, // 30 seconds
      showDemoWatermark: true
    };
  }

  /**
   * Check if demo mode is enabled
   */
  isDemoMode(): boolean {
    return this.demoConfig.enabled;
  }

  /**
   * Get current demo configuration
   */
  getConfig(): DemoConfig {
    return { ...this.demoConfig };
  }

  /**
   * Update demo configuration
   */
  updateConfig(config: Partial<DemoConfig>): void {
    this.demoConfig = { ...this.demoConfig, ...config };
    
    // Restart webhook simulation if interval changed
    if (config.webhookInterval !== undefined || config.simulateWebhooks !== undefined) {
      this.restartWebhookSimulation();
    }
  }

  /**
   * Initialize demo environment for a user
   */
  async initializeDemoUser(userId: string) {
    console.log('ðŸŽ­ Initializing demo environment for user:', userId);

    try {
      // Generate impressive demo data
      if (this.demoConfig.autoGenerateData) {
        await this.mockDataGenerator.generateDemoData(userId);
      }

      // Start webhook simulation for this user
      if (this.demoConfig.simulateWebhooks) {
        await this.startWebhookSimulation(userId);
      }

      // Generate initial performance boost
      await this.performanceSimulator.generateInitialBoost(userId);

      return {
        success: true,
        message: 'Demo environment initialized successfully',
        config: this.demoConfig
      };
    } catch (error) {
      console.error('Failed to initialize demo environment:', error);
      throw error;
    }
  }

  /**
   * Start webhook simulation for a user
   */
  private async startWebhookSimulation(userId: string) {
    // Clear existing timer if any
    const existingTimer = this.webhookTimers.get(userId);
    if (existingTimer) {
      clearInterval(existingTimer);
    }

    // Start new simulation
    const timer = setInterval(async () => {
      if (this.demoConfig.simulateWebhooks) {
        await this.webhookSimulator.simulateRandomWebhook(userId);
      }
    }, this.demoConfig.webhookInterval);

    this.webhookTimers.set(userId, timer);
  }

  /**
   * Stop webhook simulation for a user
   */
  stopWebhookSimulation(userId: string) {
    const timer = this.webhookTimers.get(userId);
    if (timer) {
      clearInterval(timer);
      this.webhookTimers.delete(userId);
    }
  }

  /**
   * Restart all webhook simulations
   */
  private async restartWebhookSimulation() {
    // Get all users with timers
    const userIds = Array.from(this.webhookTimers.keys());
    
    // Stop all timers
    userIds.forEach(userId => this.stopWebhookSimulation(userId));
    
    // Restart if enabled
    if (this.demoConfig.simulateWebhooks) {
      for (const userId of userIds) {
        await this.startWebhookSimulation(userId);
      }
    }
  }

  /**
   * Generate a specific demo scenario
   */
  async generateDemoScenario(userId: string, scenario: 'winning' | 'volatile' | 'steady') {
    console.log(`ðŸŽ¬ Generating ${scenario} demo scenario for user:`, userId);

    switch (scenario) {
      case 'winning':
        await this.performanceSimulator.generateWinningStreak(userId);
        break;
      case 'volatile':
        await this.performanceSimulator.generateVolatilePerformance(userId);
        break;
      case 'steady':
        await this.performanceSimulator.generateSteadyGrowth(userId);
        break;
    }

    return {
      success: true,
      scenario,
      message: `${scenario} scenario generated successfully`
    };
  }

  /**
   * Clean up demo data for a user
   */
  async cleanupDemoUser(userId: string) {
    console.log('ðŸ§¹ Cleaning up demo data for user:', userId);

    // Stop webhook simulation
    this.stopWebhookSimulation(userId);

    // Clean up data
    await this.mockDataGenerator.cleanupDemoData(userId);

    return {
      success: true,
      message: 'Demo data cleaned up successfully'
    };
  }

  /**
   * Get demo statistics
   */
  async getDemoStats() {
    return {
      demoMode: this.isDemoMode(),
      config: this.demoConfig,
      activeSimulations: this.webhookTimers.size,
      features: {
        mockData: 'Full trading history with realistic patterns',
        webhookSimulation: 'Live webhook activity simulation',
        performanceMetrics: 'Professional-grade analytics',
        scenarios: ['winning', 'volatile', 'steady']
      }
    };
  }
}

// Export singleton instance
export const demoService = new DemoService();
